\pagebreak
\chapter{Device Routines}
\label{chap:device}

\section{\code{omp\_is\_initial\_device} Routine}

The following example shows how the \code{omp\_is\_initial\_device} runtime library routine 
can be used to query if a code is executing on the initial host device or on a 
target device. The example then sets the number of threads in the \code{parallel} 
region based on where the code is executing.

\cexample{device}{1c}

\fexample{device}{1f}

\section{\code{omp\_get\_num\_devices} Routine}

The following example shows how the \code{omp\_get\_num\_devices} runtime library routine 
can be used to determine the number of devices.

\cexample{device}{2c}

\fexample{device}{2f}

\section{\code{omp\_set\_default\_device} and \\
\code{omp\_get\_default\_device} Routines}

The following example shows how the \code{omp\_set\_default\_device} and \code{omp\_get\_default\_device} 
runtime library routines can be used to set the default device and determine the 
default device respectively.

\cexample{device}{3c}

\fexample{device}{3f}

\section{Target Memory and Device Pointers}
\label{sec:target_memory_and_device_pointers}

\section{\code{use\_deviceptr()} and \code{is\_deviceptr()}}

The following example shows how the \code{use\_deviceptr()} clause can be used
to get a pointer to device memory, and how \code{is\_deviceptr()} can be used
to pass such a pointer into a region. 

\cexample{device}{4c}

% \fexample{device}{4f}

\section{\code{omp\_target\_alloc()}, \code{omp\_target\_memcpy()}, and
    \code{omp\_target\_free()}}

The following example shows how allocate, copy and free memory explicitly
between the host device memory space and device space.  These routines allow
separate buffers to be created and used for the device without
requiring an extra explicit host buffer, or the reuse of a single buffer
allocation to represent different memory locations as in this example.

\cexample{device}{5c}

\section{\code{omp\_associate\_ptr()} and \code{omp\_disassociate\_ptr()}}

The following example shows how allocate, copy and free memory explicitly
between the host device memory space and device space.  These routines allow
separate buffers to be created and used for the device without
requiring an extra explicit host buffer, or the reuse of a single buffer
allocation to represent different memory locations as in this example.

\cexample{device}{6c}

\section{\code{omp\_target\_memcpy\_rect()}}

The following example shows how to use \code{omp\_target\_memcpy\_rect()} to
update non-contiguous subsections of matrices between the host and device.
This is useful for halo exchanges, creating dense matrices from subsets of a
larger dense matrix, or generally copying shaped data.

\cexample{device}{7c}

